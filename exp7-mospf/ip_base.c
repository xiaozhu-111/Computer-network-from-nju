#include "ip.h"
#include "icmp.h"
#include "arpcache.h"
#include "rtable.h"
#include "arp.h"
#include "log.h"
#include <stdlib.h>
#include <assert.h>

extern pthread_mutex_t rt_lock;
// initialize ip header 
void ip_init_hdr(struct iphdr *ip, u32 saddr, u32 daddr, u16 len, u8 proto)
{
	ip->version = 4;
	ip->ihl = 5;
	ip->tos = 0;
	ip->tot_len = htons(len);
	ip->id = rand();
	ip->frag_off = htons(IP_DF);
	ip->ttl = DEFAULT_TTL;
	ip->protocol = proto;
	ip->saddr = htonl(saddr);
	ip->daddr = htonl(daddr);
	ip->checksum = ip_checksum(ip);
}

// lookup in the routing table, to find the entry with the same and longest prefix
// The input address is in host byte order.
// Tips:
// rtable is a global variable defined in rtable.c
rt_entry_t *longest_prefix_match(u32 dst)
{
	//assert(0 && "TODO: function longest_prefix_match not implemented!");
	//log(DEBUG,"use 最长前缀匹配");
	//log(DEBUG, "longest_prefix_match: dst_ip = %x", dst);
	pthread_mutex_lock(&rt_lock);
	u32 longest_mask = 0; //当前最长的前缀长度
	rt_entry_t* entry = NULL;
	rt_entry_t* best_match = NULL;
	//遍历全局路由表rtable
	list_for_each_entry(entry,&rtable,list){
		if((dst & entry->mask) == (entry->dest & entry->mask)){
			// if(entry->mask > longest_mask){
			// 	longest_mask = entry->mask;
			// 	best_match = entry;
			// }
			if(best_match==NULL){
				best_match = entry;
			}else if(best_match->mask<entry->mask)
				best_match = entry;
		}
	}
	pthread_mutex_unlock(&rt_lock);
	return best_match;
}

// different from function ip_forward_packet, ip_send_packet sends packet generated by router itself
// This function is used to send icmp packets.
// You can complete this function after completing icmp_send_packet, or directly integrate the function into icmp_send_packet.
// The interface to sendd the packet is specified by longest_prefix_match.
// 与ip_forward_packet函数不同，ip_send_packet发送的是由路由器自身产生的数据包
// 本实验中该函数仅用于发送ICMP数据包，但总体实现与ip_forward_packet类似
// 你可以在完成icmp_send_packet之后再完成该函数，也可以直接将该函数的功能集成到icmp_send_packet中
// 发送数据包的接口由longest_prefix_match指定
// 如果icmp_send_packet中更新过checksum和TTL了就不需要在该函数中更新了
void ip_send_packet(char *packet, int len)
{
	//assert(0 && "TODO: function ip_send_packet not implemented!");
	
	struct iphdr *ip = packet_to_ip_hdr(packet);
    u32 dst = ntohl(ip->daddr);
	log(DEBUG,"ip_send_packet:%d",dst);
    // 查找路由表
    rt_entry_t *entry = longest_prefix_match(dst);
    if (!entry) {
        fprintf(stderr, "ip_send_packet: No route to host " IP_FMT "\n", HOST_IP_FMT_STR(dst));
        free(packet); // 避免内存泄漏
        return;
    }

    // 下一跳 IP：如果 gateway 为 0，目标就在同一网段，下一跳就是目标本身
    u32 next_hop = (entry->gw == 0) ? dst : entry->gw;
	//log(DEBUG,"next_hop:%d",next_hop);
	
	struct ether_header *eh = (struct ether_header *)packet;
	eh->ether_type = ntohs(ETH_P_IP);
	memcpy(eh->ether_shost, entry->iface->mac, ETH_ALEN);
	//log(DEBUG,"problem is here");
    // 发送 Ethernet 包：将 packet 发给 next_hop，通过指定接口
    iface_send_packet_by_arp(entry->iface, (next_hop), packet, len);
	//log(DEBUG,"I can go away");
}
